// ===== ÈòÖËØªÂô®ËÆæÁΩÆÁÆ°ÁêÜ =====
import { createApp, ref, toRaw } from 'vue'
import { MotionPlugin } from '@vueuse/motion'
import { Dialog, showMessage, fetchSyncPost } from 'siyuan'
import type { Plugin } from 'siyuan'
import SettingsVue from '@/components/Settings.vue'

export type PdfToolbarStyle = 'float' | 'fixed'
export type PageAnimation = 'slide' | 'none'
export type ViewMode = 'single' | 'double' | 'scroll'
export type NavPosition = 'left' | 'right' | 'top' | 'bottom'
export type DocInfo = { id: string; name: string; path: string; notebook: string }
export interface ReadTheme { name: string; color: string; bg: string; bgImg?: string }
export interface FontFileInfo { name: string; displayName: string }
export interface TextSettings { fontFamily: string; fontSize: number; letterSpacing: number; customFont: { fontFamily: string; fontFile: string } }
export interface ParagraphSettings { lineHeight: number; paragraphSpacing: number; textIndent: number }
export interface LayoutSettings { marginHorizontal: number; marginVertical: number; gap: number; headerFooterMargin: number }
export interface VisualSettings { brightness: number; contrast: number; sepia: number; saturate: number; invert: boolean }
export interface ReaderSettings { enabled: boolean; openMode: 'newTab' | 'rightTab' | 'bottomTab' | 'newWindow'; navPosition: NavPosition; pageAnimation: PageAnimation; viewMode: ViewMode; theme: string; customTheme: ReadTheme; annotationMode: 'notebook' | 'document'; notebookId?: string; parentDoc?: DocInfo; linkFormat: string; pdfToolbarStyle: PdfToolbarStyle; textSettings: TextSettings; paragraphSettings: ParagraphSettings; layoutSettings: LayoutSettings; visualSettings: VisualSettings }

// ===== È¢ÑËÆæ‰∏ªÈ¢ò =====
export const PRESET_THEMES: Record<string, ReadTheme> = { default: { name: 'themeDefault', color: '#202124', bg: '#ffffff' }, auto: { name: 'themeAuto', color: 'var(--b3-theme-on-background)', bg: 'var(--b3-theme-background)' }, almond: { name: 'themeAlmond', color: '#414441', bg: '#FAF9DE' }, autumn: { name: 'themeAutumn', color: '#414441', bg: '#FFF2E2' }, green: { name: 'themeGreen', color: '#414441', bg: '#E3EDCD' }, blue: { name: 'themeBlue', color: '#414441', bg: '#DCE2F1' }, night: { name: 'themeNight', color: '#fff6e6', bg: '#415062' }, dark: { name: 'themeDark', color: '#d5cecd', bg: '#414441' }, gold: { name: 'themeGold', color: '#b58931', bg: '#081010' } }

// ===== Â∑•ÂÖ∑ÂáΩÊï∞ =====
const fixUrl = (url: string) => url.startsWith('http') || url.startsWith('/') ? url : `/${url}`
const msg = { success: (m: string) => showMessage(m, 2000, 'info'), error: (m: string) => showMessage(m, 3000, 'error') }
const getTheme = (settings: ReaderSettings) => settings.theme === 'custom' ? settings.customTheme : PRESET_THEMES[settings.theme]
const getFont = (t: TextSettings) => { const isCustom = t.fontFamily === 'custom' && t.customFont.fontFamily; return { font: isCustom ? `"${t.customFont.fontFamily}", sans-serif` : (t.fontFamily || 'inherit'), fontFace: isCustom ? `@font-face{font-family:"${t.customFont.fontFamily}";src:url("/plugins/custom-fonts/${t.customFont.fontFile}")}` : '' } }

export const applyTheme = (el: HTMLElement, settings: ReaderSettings) => { const theme = getTheme(settings); if (!theme) return; const s = el.style, img = theme.bgImg; Object.assign(s, { color: theme.color, backgroundColor: img ? 'transparent' : theme.bg, backgroundImage: img ? `url("${fixUrl(img)}")` : '', backgroundSize: img ? 'cover' : '', backgroundPosition: img ? 'center' : '', backgroundRepeat: img ? 'no-repeat' : '' }) }

export const applyPageStyles = (iframe: HTMLIFrameElement, settings: ReaderSettings) => { const doc = iframe.contentDocument; if (!doc?.body) return; const { textSettings: t, paragraphSettings: p, layoutSettings: l } = settings; doc.querySelectorAll('style[data-sireader-page]').forEach(s => s.remove()); const { font, fontFace } = getFont(t); doc.head.appendChild(Object.assign(doc.createElement('style'), { 'data-sireader-page': 'true', textContent: `${fontFace}body{font-family:${font}!important;font-size:${t.fontSize}px!important;letter-spacing:${t.letterSpacing}em!important;padding:${l.marginVertical}px ${l.marginHorizontal}px!important}p,div{line-height:${p.lineHeight}!important;margin:${p.paragraphSpacing}em 0!important}p{text-indent:${p.textIndent}em!important}` })) }

// ===== ÈªòËÆ§ÈÖçÁΩÆ =====
const DEFAULT_SETTINGS: ReaderSettings = { enabled: true, openMode: 'newTab', navPosition: 'left', pageAnimation: 'slide', viewMode: 'scroll', theme: 'default', customTheme: { name: 'custom', color: '#202124', bg: '#ffffff' }, annotationMode: 'notebook', notebookId: '', parentDoc: undefined, linkFormat: '> [!NOTE] üìë ‰π¶Âêç\n> [Á´†ËäÇ](ÈìæÊé•) ÊñáÊú¨\n> Êà™Âõæ\n> Á¨îËÆ∞', pdfToolbarStyle: 'float', textSettings: { fontFamily: 'inherit', fontSize: 16, letterSpacing: 0, customFont: { fontFamily: '', fontFile: '' } }, paragraphSettings: { lineHeight: 1.6, paragraphSpacing: 0.8, textIndent: 0 }, layoutSettings: { marginHorizontal: 40, marginVertical: 20, gap: 5, headerFooterMargin: 0 }, visualSettings: { brightness: 1, contrast: 1, sepia: 0, saturate: 1, invert: false } }

// ===== UIÈÖçÁΩÆÂ∏∏Èáè =====
const range = (key: string, min: number, max: number, step: number, unit = '') => ({ key, type: 'range' as const, min, max, step, unit })
export const UI_CONFIG = { interfaceItems: [{ key: 'openMode', opts: ['newTab', 'rightTab', 'bottomTab', 'newWindow'] }, { key: 'navPosition', opts: ['left', 'right', 'top', 'bottom'] }, { key: 'viewMode', opts: ['single', 'double', 'scroll'] }, { key: 'pageAnimation', opts: ['slide', 'none'] }, { key: 'pdfToolbarStyle', opts: ['float', 'fixed'] }], customThemeItems: [{ key: 'color', label: 'textColor', type: 'color' }, { key: 'bg', label: 'bgColor', type: 'color' }, { key: 'bgImg', label: 'bgImage', type: 'text' }], appearanceGroups: [{ title: 'textSettings', items: [range('fontSize', 12, 32, 1, 'px'), range('letterSpacing', 0, 0.2, 0.01, 'em')] }, { title: 'paragraphSettings', items: [range('lineHeight', 1.0, 3.0, 0.1), range('paragraphSpacing', 0, 2, 0.1, 'em'), range('textIndent', 0, 4, 0.5, 'em')] }, { title: 'layoutSettings', items: [range('marginHorizontal', 0, 100, 5, 'px'), range('marginVertical', 0, 80, 5, 'px'), range('gap', 0, 20, 1, '%'), range('headerFooterMargin', 0, 60, 5, 'px')] }, { title: 'visualSettings', items: [range('brightness', 0.5, 1.5, 0.05), range('contrast', 0.5, 1.5, 0.05), range('sepia', 0, 1, 0.05), range('saturate', 0, 2, 0.1), { key: 'invert', type: 'checkbox' as const }] }] }

// ===== Â≠ó‰ΩìÁÆ°ÁêÜ =====
export const scanCustomFonts = async (): Promise<FontFileInfo[]> => { try { const res = await fetchSyncPost('/api/file/readDir', { path: '/data/plugins/custom-fonts' }); return res?.code === 0 && Array.isArray(res.data) ? res.data.filter((f: any) => !f.isDir && /\.(ttf|otf|woff2?)$/i.test(f.name)).map((f: any) => ({ name: f.name, displayName: f.name.replace(/\.(ttf|otf|woff2?)$/i, '') })) : [] } catch { return [] } }
export const loadFonts = (fonts: FontFileInfo[]) => { let style = document.getElementById('sr-fonts') || Object.assign(document.createElement('style'), { id: 'sr-fonts' }); style.parentNode || document.head.appendChild(style); style.textContent = fonts.map(f => `@font-face{font-family:"${f.displayName}";src:url("/plugins/custom-fonts/${f.name}")}`).join('') }
export const resetToDefaults = (settings: any) => Object.assign(settings, { textSettings: DEFAULT_SETTINGS.textSettings, paragraphSettings: DEFAULT_SETTINGS.paragraphSettings, layoutSettings: DEFAULT_SETTINGS.layoutSettings, visualSettings: DEFAULT_SETTINGS.visualSettings })

// ===== ÈìæÊé•Ê†ºÂºèÂåñ =====
const applyTemplate = (tpl: string, vars: Record<string, string>) => Object.entries(vars).reduce((r, [k, v]) => k.split('|').reduce((s, p) => s.replace(new RegExp(p, 'g'), v), r), tpl)
export const formatBookLink = (bookUrl: string, bookTitle: string, author: string, chapter: string, cfi: string, text: string, format: string, note = '', image = '', id = '') => applyTemplate(format, { '‰π¶Âêç|{{title}}': bookTitle, '‰ΩúËÄÖ|{{author}}': author, 'Á´†ËäÇ|{{chapter}}': chapter, '‰ΩçÁΩÆ|{{location}}': cfi, 'ÈìæÊé•|{{url}}': `sireader://open?url=${id?`${bookUrl}_${id}`:bookUrl}&cfi=${cfi}`, 'ÊñáÊú¨|{{text}}': text, 'Á¨îËÆ∞|{{note}}': note, 'Êà™Âõæ|{{image}}': image }).replace(/> \n/g, '').replace(/\n\n+/g, '\n')
export const parseBookLink = (url: string): { bookUrl: string; cfi: string; id?: string } | null => { try { const m = url.match(/^sireader:\/\/open\?(.+)$/); if (!m) return null; const p = new URLSearchParams(m[1].replace(/&amp;/g, '&')); let u = p.get('url'), c = p.get('cfi'); if (!u || !c) return null; let id: string | undefined; const protocolEnd = u.indexOf('://'); if (protocolEnd !== -1) { const pathPart = u.slice(protocolEnd + 3); const idPatterns = [/_(note-[^_]+)$/, /_(shape_\d+_[^_]+)$/, /_(bookmark-[^_]+)$/]; for (const pattern of idPatterns) { const match = pathPart.match(pattern); if (match) { id = match[1]; u = u.slice(0, u.lastIndexOf('_' + id)); break } } } return { bookUrl: u, cfi: c, id } } catch { return null } }

// ===== Á¨îËÆ∞Êú¨ÂíåÊñáÊ°£ÁÆ°ÁêÜ =====
export const loadNotebooks = async () => { const res = await fetchSyncPost('/api/notebook/lsNotebooks', {}); return res?.code === 0 ? res.data?.notebooks || [] : [] }
export const searchDocs = async (keyword: string) => { const res = await fetchSyncPost('/api/filetree/searchDocs', { k: keyword }); return res?.code === 0 && Array.isArray(res.data) ? res.data : [] }
export const createDocInfo = (d: any) => ({ id: d.id, name: d.hPath || d.content || 'Êó†Ê†áÈ¢ò', path: d.path || '', notebook: d.box || '' })

// ===== ÊñáÊ°£ÊêúÁ¥¢Áä∂ÊÄÅÁÆ°ÁêÜ =====
export const useDocSearch = () => { const state = ref({ input: '', results: [] as any[], show: false }), search = async () => { const k = state.value.input.trim(); if (!k) return; state.value.results = await searchDocs(k); state.value.show = true }, select = (d: any, onSelect: (doc: DocInfo) => void) => (onSelect(createDocInfo(d)), state.value = { input: '', results: [], show: false }), reset = () => state.value = { input: '', results: [], show: false }; return { state, search, select, reset } }

// ===== Á¨îËÆ∞Êú¨Âä†ËΩΩÁÆ°ÁêÜ =====
export const useNotebooks = () => { const notebooks = ref<{ id: string; name: string; icon: string }[]>([]), load = async () => !notebooks.value.length && (notebooks.value = await loadNotebooks()); return { notebooks, load } }

// ===== ÂØπËØùÊ°ÜÂàõÂª∫ËæÖÂä© =====
export const createDialog = (title: string, id: string, component: any, props: any, plugin: any) => { const d = new Dialog({ title, content: `<div id="${id}"></div>`, width: '800px', height: '600px' }); const close = () => (app.unmount(), d.destroy()); d.element.querySelector('.b3-dialog__scrim')?.addEventListener('click', close); const app = createApp(component, props); app.use(plugin); app.mount(d.element.querySelector(`#${id}`)!); d.element.querySelector('.b3-dialog__close')?.addEventListener('click', close); return { dialog: d, app } }

// ===== ËÆæÁΩÆÁÆ°ÁêÜ =====
export function useSetting(plugin: Plugin) { const settings = ref<ReaderSettings>({ ...DEFAULT_SETTINGS }), i18n = plugin.i18n as any, customFonts = ref<FontFileInfo[]>([]), isLoadingFonts = ref(false), isLoaded = ref(false); let dialog: Dialog | null = null, app: any = null; const load = async () => { const cfg = await plugin.loadData('config.json') || {}; if (cfg.settings) { const { pageSettings, ...cleanSettings } = cfg.settings; delete cleanSettings.layoutSettings?.maxBlockSize; settings.value = { ...DEFAULT_SETTINGS, ...cleanSettings, textSettings: { ...DEFAULT_SETTINGS.textSettings, ...cleanSettings.textSettings }, layoutSettings: { ...DEFAULT_SETTINGS.layoutSettings, ...cleanSettings.layoutSettings } } } isLoaded.value = true }, save = async () => { try { const cfg = await plugin.loadData('config.json') || {}, raw = JSON.parse(JSON.stringify(toRaw(settings.value))); cfg.settings = raw; await plugin.saveData('config.json', cfg); window.dispatchEvent(new CustomEvent('sireaderSettingsUpdated', { detail: raw })); msg.success(i18n?.saved || 'ËÆæÁΩÆÂ∑≤‰øùÂ≠ò') } catch { msg.error(i18n?.saveError || '‰øùÂ≠òÂ§±Ë¥•') } }, loadCustomFonts = async () => (isLoadingFonts.value = true, customFonts.value = await scanCustomFonts(), isLoadingFonts.value = false, loadFonts(customFonts.value)), setFont = (f?: FontFileInfo, onSave?: () => void) => { settings.value.textSettings.fontFamily = f ? 'custom' : 'inherit'; if (f) settings.value.textSettings.customFont = { fontFamily: f.displayName, fontFile: f.name }; else settings.value.textSettings.customFont = { fontFamily: '', fontFile: '' }; onSave?.() }, resetStyles = () => resetToDefaults(settings.value), open = async () => { dialog && (app?.unmount(), dialog.destroy()); await load(); dialog = new Dialog({ title: i18n?.settingsTitle || 'ËÆæÁΩÆ', content: '<div id="sireader-settings-mount"></div>', width: '680px', height: '580px', destroyCallback: () => (app?.unmount(), dialog = null, app = null) }); const mountEl = dialog.element.querySelector('#sireader-settings-mount'); mountEl && (app = createApp(SettingsVue, { modelValue: settings.value, i18n, onSave: save, 'onUpdate:modelValue': (v: ReaderSettings) => settings.value = v }), app.use(MotionPlugin), app.mount(mountEl)) }; load(); return { settings, isLoaded, open, save, loadCustomFonts, setFont, resetStyles, customFonts, isLoadingFonts } }
